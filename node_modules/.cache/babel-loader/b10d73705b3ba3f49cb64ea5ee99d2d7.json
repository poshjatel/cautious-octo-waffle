{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport GoTrueApi from './GoTrueApi';\nimport { isBrowser, getParameterByName, uuid } from './lib/helpers';\nimport { GOTRUE_URL, DEFAULT_HEADERS, STORAGE_KEY } from './lib/constants';\nimport { polyfillGlobalThis } from './lib/polyfills';\npolyfillGlobalThis(); // Make \"globalThis\" available\n\nconst DEFAULT_OPTIONS = {\n  url: GOTRUE_URL,\n  autoRefreshToken: true,\n  persistSession: true,\n  detectSessionInUrl: true,\n  multiTab: true,\n  headers: DEFAULT_HEADERS\n};\nexport default class GoTrueClient {\n  /**\n   * Create a new client for use in the browser.\n   * @param options.url The URL of the GoTrue server.\n   * @param options.headers Any additional headers to send to the GoTrue server.\n   * @param options.detectSessionInUrl Set to \"true\" if you want to automatically detects OAuth grants in the URL and signs in the user.\n   * @param options.autoRefreshToken Set to \"true\" if you want to automatically refresh the token before expiring.\n   * @param options.persistSession Set to \"true\" if you want to automatically save the user session into local storage.\n   * @param options.localStorage Provide your own local storage implementation to use instead of the browser's local storage.\n   * @param options.multiTab Set to \"false\" if you want to disable multi-tab/window events.\n   * @param options.cookieOptions\n   * @param options.fetch A custom fetch implementation.\n   */\n  constructor(options) {\n    this.stateChangeEmitters = new Map();\n    const settings = Object.assign(Object.assign({}, DEFAULT_OPTIONS), options);\n    this.currentUser = null;\n    this.currentSession = null;\n    this.autoRefreshToken = settings.autoRefreshToken;\n    this.persistSession = settings.persistSession;\n    this.multiTab = settings.multiTab;\n    this.localStorage = settings.localStorage || globalThis.localStorage;\n    this.api = new GoTrueApi({\n      url: settings.url,\n      headers: settings.headers,\n      cookieOptions: settings.cookieOptions,\n      fetch: settings.fetch\n    });\n\n    this._recoverSession();\n\n    this._recoverAndRefresh();\n\n    this._listenForMultiTabEvents();\n\n    if (settings.detectSessionInUrl && isBrowser() && !!getParameterByName('access_token')) {\n      // Handle the OAuth redirect\n      this.getSessionFromUrl({\n        storeSession: true\n      }).then(_ref => {\n        let {\n          error\n        } = _ref;\n\n        if (error) {\n          console.error('Error getting session from URL.', error);\n        }\n      });\n    }\n  }\n  /**\n   * Creates a new user.\n   * @type UserCredentials\n   * @param email The user's email address.\n   * @param password The user's password.\n   * @param phone The user's phone number.\n   * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n   * @param data Optional user metadata.\n   */\n\n\n  signUp(_ref2) {\n    let {\n      email,\n      password,\n      phone\n    } = _ref2;\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        this._removeSession();\n\n        const {\n          data,\n          error\n        } = phone && password ? yield this.api.signUpWithPhone(phone, password, {\n          data: options.data\n        }) : yield this.api.signUpWithEmail(email, password, {\n          redirectTo: options.redirectTo,\n          data: options.data\n        });\n\n        if (error) {\n          throw error;\n        }\n\n        if (!data) {\n          throw 'An error occurred on sign up.';\n        }\n\n        let session = null;\n        let user = null;\n\n        if (data.access_token) {\n          session = data;\n          user = session.user;\n\n          this._saveSession(session);\n\n          this._notifyAllSubscribers('SIGNED_IN');\n        }\n\n        if (data.id) {\n          user = data;\n        }\n\n        return {\n          user,\n          session,\n          error: null\n        };\n      } catch (e) {\n        return {\n          user: null,\n          session: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Log in an existing user, or login via a third-party provider.\n   * @type UserCredentials\n   * @param email The user's email address.\n   * @param password The user's password.\n   * @param refreshToken A valid refresh token that was returned on login.\n   * @param provider One of the providers supported by GoTrue.\n   * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n   * @param scopes A space-separated list of scopes granted to the OAuth application.\n   */\n\n\n  signIn(_ref3) {\n    let {\n      email,\n      phone,\n      password,\n      refreshToken,\n      provider\n    } = _ref3;\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        this._removeSession();\n\n        if (email && !password) {\n          const {\n            error\n          } = yield this.api.sendMagicLinkEmail(email, {\n            redirectTo: options.redirectTo\n          });\n          return {\n            user: null,\n            session: null,\n            error\n          };\n        }\n\n        if (email && password) {\n          return this._handleEmailSignIn(email, password, {\n            redirectTo: options.redirectTo\n          });\n        }\n\n        if (phone && !password) {\n          const {\n            error\n          } = yield this.api.sendMobileOTP(phone);\n          return {\n            user: null,\n            session: null,\n            error\n          };\n        }\n\n        if (phone && password) {\n          return this._handlePhoneSignIn(phone, password);\n        }\n\n        if (refreshToken) {\n          // currentSession and currentUser will be updated to latest on _callRefreshToken using the passed refreshToken\n          const {\n            error\n          } = yield this._callRefreshToken(refreshToken);\n          if (error) throw error;\n          return {\n            user: this.currentUser,\n            session: this.currentSession,\n            error: null\n          };\n        }\n\n        if (provider) {\n          return this._handleProviderSignIn(provider, {\n            redirectTo: options.redirectTo,\n            scopes: options.scopes\n          });\n        }\n\n        throw new Error(`You must provide either an email, phone number or a third-party provider.`);\n      } catch (e) {\n        return {\n          user: null,\n          session: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Log in a user given a User supplied OTP received via mobile.\n   * @param phone The user's phone number.\n   * @param token The user's password.\n   * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n   */\n\n\n  verifyOTP(_ref4) {\n    let {\n      phone,\n      token\n    } = _ref4;\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        this._removeSession();\n\n        const {\n          data,\n          error\n        } = yield this.api.verifyMobileOTP(phone, token, options);\n\n        if (error) {\n          throw error;\n        }\n\n        if (!data) {\n          throw 'An error occurred on token verification.';\n        }\n\n        let session = null;\n        let user = null;\n\n        if (data.access_token) {\n          session = data;\n          user = session.user;\n\n          this._saveSession(session);\n\n          this._notifyAllSubscribers('SIGNED_IN');\n        }\n\n        if (data.id) {\n          user = data;\n        }\n\n        return {\n          user,\n          session,\n          error: null\n        };\n      } catch (e) {\n        return {\n          user: null,\n          session: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Inside a browser context, `user()` will return the user data, if there is a logged in user.\n   *\n   * For server-side management, you can get a user through `auth.api.getUserByCookie()`\n   */\n\n\n  user() {\n    return this.currentUser;\n  }\n  /**\n   * Returns the session data, if there is an active session.\n   */\n\n\n  session() {\n    return this.currentSession;\n  }\n  /**\n   * Force refreshes the session including the user data in case it was updated in a different session.\n   */\n\n\n  refreshSession() {\n    var _a;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        if (!((_a = this.currentSession) === null || _a === void 0 ? void 0 : _a.access_token)) throw new Error('Not logged in.'); // currentSession and currentUser will be updated to latest on _callRefreshToken\n\n        const {\n          error\n        } = yield this._callRefreshToken();\n        if (error) throw error;\n        return {\n          data: this.currentSession,\n          user: this.currentUser,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          user: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Updates user data, if there is a logged in user.\n   */\n\n\n  update(attributes) {\n    var _a;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        if (!((_a = this.currentSession) === null || _a === void 0 ? void 0 : _a.access_token)) throw new Error('Not logged in.');\n        const {\n          user,\n          error\n        } = yield this.api.updateUser(this.currentSession.access_token, attributes);\n        if (error) throw error;\n        if (!user) throw Error('Invalid user data.');\n        const session = Object.assign(Object.assign({}, this.currentSession), {\n          user\n        });\n\n        this._saveSession(session);\n\n        this._notifyAllSubscribers('USER_UPDATED');\n\n        return {\n          data: user,\n          user,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          user: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Sets the session data from refresh_token and returns current Session and Error\n   * @param refresh_token a JWT token\n   */\n\n\n  setSession(refresh_token) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        if (!refresh_token) {\n          throw new Error('No current session.');\n        }\n\n        const {\n          data,\n          error\n        } = yield this.api.refreshAccessToken(refresh_token);\n\n        if (error) {\n          return {\n            session: null,\n            error: error\n          };\n        }\n\n        this._saveSession(data);\n\n        this._notifyAllSubscribers('SIGNED_IN');\n\n        return {\n          session: data,\n          error: null\n        };\n      } catch (e) {\n        return {\n          error: e,\n          session: null\n        };\n      }\n    });\n  }\n  /**\n   * Overrides the JWT on the current client. The JWT will then be sent in all subsequent network requests.\n   * @param access_token a jwt access token\n   */\n\n\n  setAuth(access_token) {\n    this.currentSession = Object.assign(Object.assign({}, this.currentSession), {\n      access_token,\n      token_type: 'bearer',\n      user: null\n    });\n    return this.currentSession;\n  }\n  /**\n   * Gets the session data from a URL string\n   * @param options.storeSession Optionally store the session in the browser\n   */\n\n\n  getSessionFromUrl(options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        if (!isBrowser()) throw new Error('No browser detected.');\n        const error_description = getParameterByName('error_description');\n        if (error_description) throw new Error(error_description);\n        const provider_token = getParameterByName('provider_token');\n        const access_token = getParameterByName('access_token');\n        if (!access_token) throw new Error('No access_token detected.');\n        const expires_in = getParameterByName('expires_in');\n        if (!expires_in) throw new Error('No expires_in detected.');\n        const refresh_token = getParameterByName('refresh_token');\n        if (!refresh_token) throw new Error('No refresh_token detected.');\n        const token_type = getParameterByName('token_type');\n        if (!token_type) throw new Error('No token_type detected.');\n        const timeNow = Math.round(Date.now() / 1000);\n        const expires_at = timeNow + parseInt(expires_in);\n        const {\n          user,\n          error\n        } = yield this.api.getUser(access_token);\n        if (error) throw error;\n        const session = {\n          provider_token,\n          access_token,\n          expires_in: parseInt(expires_in),\n          expires_at,\n          refresh_token,\n          token_type,\n          user: user\n        };\n\n        if (options === null || options === void 0 ? void 0 : options.storeSession) {\n          this._saveSession(session);\n\n          const recoveryMode = getParameterByName('type');\n\n          this._notifyAllSubscribers('SIGNED_IN');\n\n          if (recoveryMode === 'recovery') {\n            this._notifyAllSubscribers('PASSWORD_RECOVERY');\n          }\n        } // Remove tokens from URL\n\n\n        window.location.hash = '';\n        return {\n          data: session,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Inside a browser context, `signOut()` will remove the logged in user from the browser session\n   * and log them out - removing all items from localstorage and then trigger a \"SIGNED_OUT\" event.\n   *\n   * For server-side management, you can disable sessions by passing a JWT through to `auth.api.signOut(JWT: string)`\n   */\n\n\n  signOut() {\n    var _a;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      const accessToken = (_a = this.currentSession) === null || _a === void 0 ? void 0 : _a.access_token;\n\n      this._removeSession();\n\n      this._notifyAllSubscribers('SIGNED_OUT');\n\n      if (accessToken) {\n        const {\n          error\n        } = yield this.api.signOut(accessToken);\n        if (error) return {\n          error\n        };\n      }\n\n      return {\n        error: null\n      };\n    });\n  }\n  /**\n   * Receive a notification every time an auth event happens.\n   * @returns {Subscription} A subscription object which can be used to unsubscribe itself.\n   */\n\n\n  onAuthStateChange(callback) {\n    try {\n      const id = uuid();\n      const subscription = {\n        id,\n        callback,\n        unsubscribe: () => {\n          this.stateChangeEmitters.delete(id);\n        }\n      };\n      this.stateChangeEmitters.set(id, subscription);\n      return {\n        data: subscription,\n        error: null\n      };\n    } catch (e) {\n      return {\n        data: null,\n        error: e\n      };\n    }\n  }\n\n  _handleEmailSignIn(email, password) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    var _a, _b;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const {\n          data,\n          error\n        } = yield this.api.signInWithEmail(email, password, {\n          redirectTo: options.redirectTo\n        });\n        if (error || !data) return {\n          data: null,\n          user: null,\n          session: null,\n          error\n        };\n\n        if (((_a = data === null || data === void 0 ? void 0 : data.user) === null || _a === void 0 ? void 0 : _a.confirmed_at) || ((_b = data === null || data === void 0 ? void 0 : data.user) === null || _b === void 0 ? void 0 : _b.email_confirmed_at)) {\n          this._saveSession(data);\n\n          this._notifyAllSubscribers('SIGNED_IN');\n        }\n\n        return {\n          data,\n          user: data.user,\n          session: data,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          user: null,\n          session: null,\n          error: e\n        };\n      }\n    });\n  }\n\n  _handlePhoneSignIn(phone, password) {\n    var _a;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const {\n          data,\n          error\n        } = yield this.api.signInWithPhone(phone, password);\n        if (error || !data) return {\n          data: null,\n          user: null,\n          session: null,\n          error\n        };\n\n        if ((_a = data === null || data === void 0 ? void 0 : data.user) === null || _a === void 0 ? void 0 : _a.phone_confirmed_at) {\n          this._saveSession(data);\n\n          this._notifyAllSubscribers('SIGNED_IN');\n        }\n\n        return {\n          data,\n          user: data.user,\n          session: data,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          user: null,\n          session: null,\n          error: e\n        };\n      }\n    });\n  }\n\n  _handleProviderSignIn(provider) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const url = this.api.getUrlForProvider(provider, {\n      redirectTo: options.redirectTo,\n      scopes: options.scopes\n    });\n\n    try {\n      // try to open on the browser\n      if (isBrowser()) {\n        window.location.href = url;\n      }\n\n      return {\n        provider,\n        url,\n        data: null,\n        session: null,\n        user: null,\n        error: null\n      };\n    } catch (e) {\n      // fallback to returning the URL\n      if (url) return {\n        provider,\n        url,\n        data: null,\n        session: null,\n        user: null,\n        error: null\n      };\n      return {\n        data: null,\n        user: null,\n        session: null,\n        error: e\n      };\n    }\n  }\n  /**\n   * Attempts to get the session from LocalStorage\n   * Note: this should never be async (even for React Native), as we need it to return immediately in the constructor.\n   */\n\n\n  _recoverSession() {\n    var _a;\n\n    try {\n      const json = isBrowser() && ((_a = this.localStorage) === null || _a === void 0 ? void 0 : _a.getItem(STORAGE_KEY));\n\n      if (!json || typeof json !== 'string') {\n        return null;\n      }\n\n      const data = JSON.parse(json);\n      const {\n        currentSession,\n        expiresAt\n      } = data;\n      const timeNow = Math.round(Date.now() / 1000);\n\n      if (expiresAt >= timeNow && (currentSession === null || currentSession === void 0 ? void 0 : currentSession.user)) {\n        this._saveSession(currentSession);\n\n        this._notifyAllSubscribers('SIGNED_IN');\n      }\n    } catch (error) {\n      console.log('error', error);\n    }\n  }\n  /**\n   * Recovers the session from LocalStorage and refreshes\n   * Note: this method is async to accommodate for AsyncStorage e.g. in React native.\n   */\n\n\n  _recoverAndRefresh() {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const json = isBrowser() && (yield this.localStorage.getItem(STORAGE_KEY));\n\n        if (!json) {\n          return null;\n        }\n\n        const data = JSON.parse(json);\n        const {\n          currentSession,\n          expiresAt\n        } = data;\n        const timeNow = Math.round(Date.now() / 1000);\n\n        if (expiresAt < timeNow) {\n          if (this.autoRefreshToken && currentSession.refresh_token) {\n            const {\n              error\n            } = yield this._callRefreshToken(currentSession.refresh_token);\n\n            if (error) {\n              console.log(error.message);\n              yield this._removeSession();\n            }\n          } else {\n            this._removeSession();\n          }\n        } else if (!currentSession || !currentSession.user) {\n          console.log('Current session is missing data.');\n\n          this._removeSession();\n        } else {\n          // should be handled on _recoverSession method already\n          // But we still need the code here to accommodate for AsyncStorage e.g. in React native\n          this._saveSession(currentSession);\n\n          this._notifyAllSubscribers('SIGNED_IN');\n        }\n      } catch (err) {\n        console.error(err);\n        return null;\n      }\n    });\n  }\n\n  _callRefreshToken(refresh_token) {\n    var _a;\n\n    if (refresh_token === void 0) {\n      refresh_token = (_a = this.currentSession) === null || _a === void 0 ? void 0 : _a.refresh_token;\n    }\n\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        if (!refresh_token) {\n          throw new Error('No current session.');\n        }\n\n        const {\n          data,\n          error\n        } = yield this.api.refreshAccessToken(refresh_token);\n        if (error) throw error;\n        if (!data) throw Error('Invalid session data.');\n\n        this._saveSession(data);\n\n        this._notifyAllSubscribers('TOKEN_REFRESHED');\n\n        this._notifyAllSubscribers('SIGNED_IN');\n\n        return {\n          data,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n\n  _notifyAllSubscribers(event) {\n    this.stateChangeEmitters.forEach(x => x.callback(event, this.currentSession));\n  }\n  /**\n   * set currentSession and currentUser\n   * process to _startAutoRefreshToken if possible\n   */\n\n\n  _saveSession(session) {\n    this.currentSession = session;\n    this.currentUser = session.user;\n    const expiresAt = session.expires_at;\n\n    if (expiresAt) {\n      const timeNow = Math.round(Date.now() / 1000);\n      const expiresIn = expiresAt - timeNow;\n      const refreshDurationBeforeExpires = expiresIn > 60 ? 60 : 0.5;\n\n      this._startAutoRefreshToken((expiresIn - refreshDurationBeforeExpires) * 1000);\n    } // Do we need any extra check before persist session\n    // access_token or user ?\n\n\n    if (this.persistSession && session.expires_at) {\n      this._persistSession(this.currentSession);\n    }\n  }\n\n  _persistSession(currentSession) {\n    const data = {\n      currentSession,\n      expiresAt: currentSession.expires_at\n    };\n    isBrowser() && this.localStorage.setItem(STORAGE_KEY, JSON.stringify(data));\n  }\n\n  _removeSession() {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.currentSession = null;\n      this.currentUser = null;\n      if (this.refreshTokenTimer) clearTimeout(this.refreshTokenTimer);\n      isBrowser() && (yield this.localStorage.removeItem(STORAGE_KEY));\n    });\n  }\n  /**\n   * Clear and re-create refresh token timer\n   * @param value time intervals in milliseconds\n   */\n\n\n  _startAutoRefreshToken(value) {\n    if (this.refreshTokenTimer) clearTimeout(this.refreshTokenTimer);\n    if (value <= 0 || !this.autoRefreshToken) return;\n    this.refreshTokenTimer = setTimeout(() => this._callRefreshToken(), value);\n    if (typeof this.refreshTokenTimer.unref === 'function') this.refreshTokenTimer.unref();\n  }\n  /**\n   * Listens for changes to LocalStorage and updates the current session.\n   */\n\n\n  _listenForMultiTabEvents() {\n    if (!this.multiTab || !isBrowser() || !(window === null || window === void 0 ? void 0 : window.addEventListener)) {\n      // console.debug('Auth multi-tab support is disabled.')\n      return false;\n    }\n\n    try {\n      window === null || window === void 0 ? void 0 : window.addEventListener('storage', e => {\n        var _a;\n\n        if (e.key === STORAGE_KEY) {\n          const newSession = JSON.parse(String(e.newValue));\n\n          if ((_a = newSession === null || newSession === void 0 ? void 0 : newSession.currentSession) === null || _a === void 0 ? void 0 : _a.access_token) {\n            this._recoverAndRefresh();\n\n            this._notifyAllSubscribers('SIGNED_IN');\n          } else {\n            this._removeSession();\n\n            this._notifyAllSubscribers('SIGNED_OUT');\n          }\n        }\n      });\n    } catch (error) {\n      console.error('_listenForMultiTabEvents', error);\n    }\n  }\n\n}","map":{"version":3,"sources":["/Users/joshpatel/supa-react/node_modules/@supabase/gotrue-js/src/GoTrueClient.ts"],"names":[],"mappings":"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","sourcesContent":["import GoTrueApi from './GoTrueApi'\nimport { isBrowser, getParameterByName, uuid } from './lib/helpers'\nimport { GOTRUE_URL, DEFAULT_HEADERS, STORAGE_KEY } from './lib/constants'\nimport { polyfillGlobalThis } from './lib/polyfills'\nimport { Fetch } from './lib/fetch'\n\nimport type {\n  ApiError,\n  Session,\n  User,\n  UserAttributes,\n  Provider,\n  Subscription,\n  AuthChangeEvent,\n  CookieOptions,\n  UserCredentials,\n  VerifyOTPParams,\n} from './lib/types'\n\npolyfillGlobalThis() // Make \"globalThis\" available\n\nconst DEFAULT_OPTIONS = {\n  url: GOTRUE_URL,\n  autoRefreshToken: true,\n  persistSession: true,\n  detectSessionInUrl: true,\n  multiTab: true,\n  headers: DEFAULT_HEADERS,\n}\n\ntype AnyFunction = (...args: any[]) => any\ntype MaybePromisify<T> = T | Promise<T>\n\ntype PromisifyMethods<T> = {\n  [K in keyof T]: T[K] extends AnyFunction\n    ? (...args: Parameters<T[K]>) => MaybePromisify<ReturnType<T[K]>>\n    : T[K]\n}\n\ntype SupportedStorage = PromisifyMethods<Pick<Storage, 'getItem' | 'setItem' | 'removeItem'>>\n\nexport default class GoTrueClient {\n  /**\n   * Namespace for the GoTrue API methods.\n   * These can be used for example to get a user from a JWT in a server environment or reset a user's password.\n   */\n  api: GoTrueApi\n  /**\n   * The currently logged in user or null.\n   */\n  protected currentUser: User | null\n  /**\n   * The session object for the currently logged in user or null.\n   */\n  protected currentSession: Session | null\n\n  protected autoRefreshToken: boolean\n  protected persistSession: boolean\n  protected localStorage: SupportedStorage\n  protected multiTab: boolean\n  protected stateChangeEmitters: Map<string, Subscription> = new Map()\n  protected refreshTokenTimer?: ReturnType<typeof setTimeout>\n\n  /**\n   * Create a new client for use in the browser.\n   * @param options.url The URL of the GoTrue server.\n   * @param options.headers Any additional headers to send to the GoTrue server.\n   * @param options.detectSessionInUrl Set to \"true\" if you want to automatically detects OAuth grants in the URL and signs in the user.\n   * @param options.autoRefreshToken Set to \"true\" if you want to automatically refresh the token before expiring.\n   * @param options.persistSession Set to \"true\" if you want to automatically save the user session into local storage.\n   * @param options.localStorage Provide your own local storage implementation to use instead of the browser's local storage.\n   * @param options.multiTab Set to \"false\" if you want to disable multi-tab/window events.\n   * @param options.cookieOptions\n   * @param options.fetch A custom fetch implementation.\n   */\n  constructor(options: {\n    url?: string\n    headers?: { [key: string]: string }\n    detectSessionInUrl?: boolean\n    autoRefreshToken?: boolean\n    persistSession?: boolean\n    localStorage?: SupportedStorage\n    multiTab?: boolean\n    cookieOptions?: CookieOptions\n    fetch?: Fetch\n  }) {\n    const settings = { ...DEFAULT_OPTIONS, ...options }\n    this.currentUser = null\n    this.currentSession = null\n    this.autoRefreshToken = settings.autoRefreshToken\n    this.persistSession = settings.persistSession\n    this.multiTab = settings.multiTab\n    this.localStorage = settings.localStorage || globalThis.localStorage\n    this.api = new GoTrueApi({\n      url: settings.url,\n      headers: settings.headers,\n      cookieOptions: settings.cookieOptions,\n      fetch: settings.fetch,\n    })\n    this._recoverSession()\n    this._recoverAndRefresh()\n    this._listenForMultiTabEvents()\n\n    if (settings.detectSessionInUrl && isBrowser() && !!getParameterByName('access_token')) {\n      // Handle the OAuth redirect\n      this.getSessionFromUrl({ storeSession: true }).then(({ error }) => {\n        if (error) {\n          console.error('Error getting session from URL.', error)\n        }\n      })\n    }\n  }\n\n  /**\n   * Creates a new user.\n   * @type UserCredentials\n   * @param email The user's email address.\n   * @param password The user's password.\n   * @param phone The user's phone number.\n   * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n   * @param data Optional user metadata.\n   */\n  async signUp(\n    { email, password, phone }: UserCredentials,\n    options: {\n      redirectTo?: string\n      data?: object\n    } = {}\n  ): Promise<{\n    user: User | null\n    session: Session | null\n    error: ApiError | null\n  }> {\n    try {\n      this._removeSession()\n\n      const { data, error } =\n        phone && password\n          ? await this.api.signUpWithPhone(phone!, password!, {\n              data: options.data,\n            })\n          : await this.api.signUpWithEmail(email!, password!, {\n              redirectTo: options.redirectTo,\n              data: options.data,\n            })\n\n      if (error) {\n        throw error\n      }\n\n      if (!data) {\n        throw 'An error occurred on sign up.'\n      }\n\n      let session: Session | null = null\n      let user: User | null = null\n\n      if ((data as Session).access_token) {\n        session = data as Session\n        user = session.user as User\n        this._saveSession(session)\n        this._notifyAllSubscribers('SIGNED_IN')\n      }\n\n      if ((data as User).id) {\n        user = data as User\n      }\n\n      return { user, session, error: null }\n    } catch (e) {\n      return { user: null, session: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Log in an existing user, or login via a third-party provider.\n   * @type UserCredentials\n   * @param email The user's email address.\n   * @param password The user's password.\n   * @param refreshToken A valid refresh token that was returned on login.\n   * @param provider One of the providers supported by GoTrue.\n   * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n   * @param scopes A space-separated list of scopes granted to the OAuth application.\n   */\n  async signIn(\n    { email, phone, password, refreshToken, provider }: UserCredentials,\n    options: {\n      redirectTo?: string\n      scopes?: string\n    } = {}\n  ): Promise<{\n    session: Session | null\n    user: User | null\n    provider?: Provider\n    url?: string | null\n    error: ApiError | null\n  }> {\n    try {\n      this._removeSession()\n\n      if (email && !password) {\n        const { error } = await this.api.sendMagicLinkEmail(email, {\n          redirectTo: options.redirectTo,\n        })\n        return { user: null, session: null, error }\n      }\n      if (email && password) {\n        return this._handleEmailSignIn(email, password, {\n          redirectTo: options.redirectTo,\n        })\n      }\n      if (phone && !password) {\n        const { error } = await this.api.sendMobileOTP(phone)\n        return { user: null, session: null, error }\n      }\n      if (phone && password) {\n        return this._handlePhoneSignIn(phone, password)\n      }\n      if (refreshToken) {\n        // currentSession and currentUser will be updated to latest on _callRefreshToken using the passed refreshToken\n        const { error } = await this._callRefreshToken(refreshToken)\n        if (error) throw error\n\n        return {\n          user: this.currentUser,\n          session: this.currentSession,\n          error: null,\n        }\n      }\n      if (provider) {\n        return this._handleProviderSignIn(provider, {\n          redirectTo: options.redirectTo,\n          scopes: options.scopes,\n        })\n      }\n      throw new Error(`You must provide either an email, phone number or a third-party provider.`)\n    } catch (e) {\n      return { user: null, session: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Log in a user given a User supplied OTP received via mobile.\n   * @param phone The user's phone number.\n   * @param token The user's password.\n   * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n   */\n  async verifyOTP(\n    { phone, token }: VerifyOTPParams,\n    options: {\n      redirectTo?: string\n    } = {}\n  ): Promise<{\n    user: User | null\n    session: Session | null\n    error: ApiError | null\n  }> {\n    try {\n      this._removeSession()\n\n      const { data, error } = await this.api.verifyMobileOTP(phone, token, options)\n\n      if (error) {\n        throw error\n      }\n\n      if (!data) {\n        throw 'An error occurred on token verification.'\n      }\n\n      let session: Session | null = null\n      let user: User | null = null\n\n      if ((data as Session).access_token) {\n        session = data as Session\n        user = session.user as User\n        this._saveSession(session)\n        this._notifyAllSubscribers('SIGNED_IN')\n      }\n\n      if ((data as User).id) {\n        user = data as User\n      }\n\n      return { user, session, error: null }\n    } catch (e) {\n      return { user: null, session: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Inside a browser context, `user()` will return the user data, if there is a logged in user.\n   *\n   * For server-side management, you can get a user through `auth.api.getUserByCookie()`\n   */\n  user(): User | null {\n    return this.currentUser\n  }\n\n  /**\n   * Returns the session data, if there is an active session.\n   */\n  session(): Session | null {\n    return this.currentSession\n  }\n\n  /**\n   * Force refreshes the session including the user data in case it was updated in a different session.\n   */\n  async refreshSession(): Promise<{\n    data: Session | null\n    user: User | null\n    error: ApiError | null\n  }> {\n    try {\n      if (!this.currentSession?.access_token) throw new Error('Not logged in.')\n\n      // currentSession and currentUser will be updated to latest on _callRefreshToken\n      const { error } = await this._callRefreshToken()\n      if (error) throw error\n\n      return { data: this.currentSession, user: this.currentUser, error: null }\n    } catch (e) {\n      return { data: null, user: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Updates user data, if there is a logged in user.\n   */\n  async update(\n    attributes: UserAttributes\n  ): Promise<{ data: User | null; user: User | null; error: ApiError | null }> {\n    try {\n      if (!this.currentSession?.access_token) throw new Error('Not logged in.')\n\n      const { user, error } = await this.api.updateUser(\n        this.currentSession.access_token,\n        attributes\n      )\n      if (error) throw error\n      if (!user) throw Error('Invalid user data.')\n\n      const session = { ...this.currentSession, user }\n      this._saveSession(session)\n      this._notifyAllSubscribers('USER_UPDATED')\n\n      return { data: user, user, error: null }\n    } catch (e) {\n      return { data: null, user: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Sets the session data from refresh_token and returns current Session and Error\n   * @param refresh_token a JWT token\n   */\n  async setSession(\n    refresh_token: string\n  ): Promise<{ session: Session | null; error: ApiError | null }> {\n    try {\n      if (!refresh_token) {\n        throw new Error('No current session.')\n      }\n      const { data, error } = await this.api.refreshAccessToken(refresh_token)\n      if (error) {\n        return { session: null, error: error }\n      }\n\n      this._saveSession(data!)\n      this._notifyAllSubscribers('SIGNED_IN')\n      return { session: data, error: null }\n    } catch (e) {\n      return { error: e as ApiError, session: null }\n    }\n  }\n\n  /**\n   * Overrides the JWT on the current client. The JWT will then be sent in all subsequent network requests.\n   * @param access_token a jwt access token\n   */\n  setAuth(access_token: string): Session {\n    this.currentSession = {\n      ...this.currentSession,\n      access_token,\n      token_type: 'bearer',\n      user: null,\n    }\n\n    return this.currentSession\n  }\n\n  /**\n   * Gets the session data from a URL string\n   * @param options.storeSession Optionally store the session in the browser\n   */\n  async getSessionFromUrl(options?: {\n    storeSession?: boolean\n  }): Promise<{ data: Session | null; error: ApiError | null }> {\n    try {\n      if (!isBrowser()) throw new Error('No browser detected.')\n\n      const error_description = getParameterByName('error_description')\n      if (error_description) throw new Error(error_description)\n\n      const provider_token = getParameterByName('provider_token')\n      const access_token = getParameterByName('access_token')\n      if (!access_token) throw new Error('No access_token detected.')\n      const expires_in = getParameterByName('expires_in')\n      if (!expires_in) throw new Error('No expires_in detected.')\n      const refresh_token = getParameterByName('refresh_token')\n      if (!refresh_token) throw new Error('No refresh_token detected.')\n      const token_type = getParameterByName('token_type')\n      if (!token_type) throw new Error('No token_type detected.')\n\n      const timeNow = Math.round(Date.now() / 1000)\n      const expires_at = timeNow + parseInt(expires_in)\n\n      const { user, error } = await this.api.getUser(access_token)\n      if (error) throw error\n\n      const session: Session = {\n        provider_token,\n        access_token,\n        expires_in: parseInt(expires_in),\n        expires_at,\n        refresh_token,\n        token_type,\n        user: user!,\n      }\n      if (options?.storeSession) {\n        this._saveSession(session)\n        const recoveryMode = getParameterByName('type')\n        this._notifyAllSubscribers('SIGNED_IN')\n        if (recoveryMode === 'recovery') {\n          this._notifyAllSubscribers('PASSWORD_RECOVERY')\n        }\n      }\n      // Remove tokens from URL\n      window.location.hash = ''\n\n      return { data: session, error: null }\n    } catch (e) {\n      return { data: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Inside a browser context, `signOut()` will remove the logged in user from the browser session\n   * and log them out - removing all items from localstorage and then trigger a \"SIGNED_OUT\" event.\n   *\n   * For server-side management, you can disable sessions by passing a JWT through to `auth.api.signOut(JWT: string)`\n   */\n  async signOut(): Promise<{ error: ApiError | null }> {\n    const accessToken = this.currentSession?.access_token\n    this._removeSession()\n    this._notifyAllSubscribers('SIGNED_OUT')\n    if (accessToken) {\n      const { error } = await this.api.signOut(accessToken)\n      if (error) return { error }\n    }\n    return { error: null }\n  }\n\n  /**\n   * Receive a notification every time an auth event happens.\n   * @returns {Subscription} A subscription object which can be used to unsubscribe itself.\n   */\n  onAuthStateChange(callback: (event: AuthChangeEvent, session: Session | null) => void): {\n    data: Subscription | null\n    error: ApiError | null\n  } {\n    try {\n      const id: string = uuid()\n      const subscription: Subscription = {\n        id,\n        callback,\n        unsubscribe: () => {\n          this.stateChangeEmitters.delete(id)\n        },\n      }\n      this.stateChangeEmitters.set(id, subscription)\n      return { data: subscription, error: null }\n    } catch (e) {\n      return { data: null, error: e as ApiError }\n    }\n  }\n\n  private async _handleEmailSignIn(\n    email: string,\n    password: string,\n    options: {\n      redirectTo?: string\n    } = {}\n  ) {\n    try {\n      const { data, error } = await this.api.signInWithEmail(email, password, {\n        redirectTo: options.redirectTo,\n      })\n      if (error || !data) return { data: null, user: null, session: null, error }\n\n      if (data?.user?.confirmed_at || data?.user?.email_confirmed_at) {\n        this._saveSession(data)\n        this._notifyAllSubscribers('SIGNED_IN')\n      }\n\n      return { data, user: data.user, session: data, error: null }\n    } catch (e) {\n      return { data: null, user: null, session: null, error: e as ApiError }\n    }\n  }\n\n  private async _handlePhoneSignIn(phone: string, password: string) {\n    try {\n      const { data, error } = await this.api.signInWithPhone(phone, password)\n      if (error || !data) return { data: null, user: null, session: null, error }\n\n      if (data?.user?.phone_confirmed_at) {\n        this._saveSession(data)\n        this._notifyAllSubscribers('SIGNED_IN')\n      }\n\n      return { data, user: data.user, session: data, error: null }\n    } catch (e) {\n      return { data: null, user: null, session: null, error: e as ApiError }\n    }\n  }\n\n  private _handleProviderSignIn(\n    provider: Provider,\n    options: {\n      redirectTo?: string\n      scopes?: string\n    } = {}\n  ) {\n    const url: string = this.api.getUrlForProvider(provider, {\n      redirectTo: options.redirectTo,\n      scopes: options.scopes,\n    })\n\n    try {\n      // try to open on the browser\n      if (isBrowser()) {\n        window.location.href = url\n      }\n      return { provider, url, data: null, session: null, user: null, error: null }\n    } catch (e) {\n      // fallback to returning the URL\n      if (url) return { provider, url, data: null, session: null, user: null, error: null }\n      return { data: null, user: null, session: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Attempts to get the session from LocalStorage\n   * Note: this should never be async (even for React Native), as we need it to return immediately in the constructor.\n   */\n  private _recoverSession() {\n    try {\n      const json = isBrowser() && this.localStorage?.getItem(STORAGE_KEY)\n      if (!json || typeof json !== 'string') {\n        return null\n      }\n\n      const data = JSON.parse(json)\n      const { currentSession, expiresAt } = data\n      const timeNow = Math.round(Date.now() / 1000)\n\n      if (expiresAt >= timeNow && currentSession?.user) {\n        this._saveSession(currentSession)\n        this._notifyAllSubscribers('SIGNED_IN')\n      }\n    } catch (error) {\n      console.log('error', error)\n    }\n  }\n\n  /**\n   * Recovers the session from LocalStorage and refreshes\n   * Note: this method is async to accommodate for AsyncStorage e.g. in React native.\n   */\n  private async _recoverAndRefresh() {\n    try {\n      const json = isBrowser() && (await this.localStorage.getItem(STORAGE_KEY))\n      if (!json) {\n        return null\n      }\n\n      const data = JSON.parse(json)\n      const { currentSession, expiresAt } = data\n      const timeNow = Math.round(Date.now() / 1000)\n\n      if (expiresAt < timeNow) {\n        if (this.autoRefreshToken && currentSession.refresh_token) {\n          const { error } = await this._callRefreshToken(currentSession.refresh_token)\n          if (error) {\n            console.log(error.message)\n            await this._removeSession()\n          }\n        } else {\n          this._removeSession()\n        }\n      } else if (!currentSession || !currentSession.user) {\n        console.log('Current session is missing data.')\n        this._removeSession()\n      } else {\n        // should be handled on _recoverSession method already\n        // But we still need the code here to accommodate for AsyncStorage e.g. in React native\n        this._saveSession(currentSession)\n        this._notifyAllSubscribers('SIGNED_IN')\n      }\n    } catch (err) {\n      console.error(err)\n      return null\n    }\n  }\n\n  private async _callRefreshToken(refresh_token = this.currentSession?.refresh_token) {\n    try {\n      if (!refresh_token) {\n        throw new Error('No current session.')\n      }\n      const { data, error } = await this.api.refreshAccessToken(refresh_token)\n      if (error) throw error\n      if (!data) throw Error('Invalid session data.')\n\n      this._saveSession(data)\n      this._notifyAllSubscribers('TOKEN_REFRESHED')\n      this._notifyAllSubscribers('SIGNED_IN')\n\n      return { data, error: null }\n    } catch (e) {\n      return { data: null, error: e as ApiError }\n    }\n  }\n\n  private _notifyAllSubscribers(event: AuthChangeEvent) {\n    this.stateChangeEmitters.forEach((x) => x.callback(event, this.currentSession))\n  }\n\n  /**\n   * set currentSession and currentUser\n   * process to _startAutoRefreshToken if possible\n   */\n  private _saveSession(session: Session) {\n    this.currentSession = session\n    this.currentUser = session.user\n\n    const expiresAt = session.expires_at\n    if (expiresAt) {\n      const timeNow = Math.round(Date.now() / 1000)\n      const expiresIn = expiresAt - timeNow\n      const refreshDurationBeforeExpires = expiresIn > 60 ? 60 : 0.5\n      this._startAutoRefreshToken((expiresIn - refreshDurationBeforeExpires) * 1000)\n    }\n\n    // Do we need any extra check before persist session\n    // access_token or user ?\n    if (this.persistSession && session.expires_at) {\n      this._persistSession(this.currentSession)\n    }\n  }\n\n  private _persistSession(currentSession: Session) {\n    const data = { currentSession, expiresAt: currentSession.expires_at }\n    isBrowser() && this.localStorage.setItem(STORAGE_KEY, JSON.stringify(data))\n  }\n\n  private async _removeSession() {\n    this.currentSession = null\n    this.currentUser = null\n    if (this.refreshTokenTimer) clearTimeout(this.refreshTokenTimer)\n    isBrowser() && (await this.localStorage.removeItem(STORAGE_KEY))\n  }\n\n  /**\n   * Clear and re-create refresh token timer\n   * @param value time intervals in milliseconds\n   */\n  private _startAutoRefreshToken(value: number) {\n    if (this.refreshTokenTimer) clearTimeout(this.refreshTokenTimer)\n    if (value <= 0 || !this.autoRefreshToken) return\n\n    this.refreshTokenTimer = setTimeout(() => this._callRefreshToken(), value)\n    if (typeof this.refreshTokenTimer.unref === 'function') this.refreshTokenTimer.unref()\n  }\n\n  /**\n   * Listens for changes to LocalStorage and updates the current session.\n   */\n  private _listenForMultiTabEvents() {\n    if (!this.multiTab || !isBrowser() || !window?.addEventListener) {\n      // console.debug('Auth multi-tab support is disabled.')\n      return false\n    }\n\n    try {\n      window?.addEventListener('storage', (e: StorageEvent) => {\n        if (e.key === STORAGE_KEY) {\n          const newSession = JSON.parse(String(e.newValue))\n          if (newSession?.currentSession?.access_token) {\n            this._recoverAndRefresh()\n            this._notifyAllSubscribers('SIGNED_IN')\n          } else {\n            this._removeSession()\n            this._notifyAllSubscribers('SIGNED_OUT')\n          }\n        }\n      })\n    } catch (error) {\n      console.error('_listenForMultiTabEvents', error)\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}