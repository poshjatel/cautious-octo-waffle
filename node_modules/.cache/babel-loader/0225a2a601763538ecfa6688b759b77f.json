{"ast":null,"code":"/**\n * Helpers to convert the change Payload into native JS types.\n */\n// Adapted from epgsql (src/epgsql_binary.erl), this module licensed under\n// 3-clause BSD found here: https://raw.githubusercontent.com/epgsql/epgsql/devel/LICENSE\nexport var PostgresTypes;\n\n(function (PostgresTypes) {\n  PostgresTypes[\"abstime\"] = \"abstime\";\n  PostgresTypes[\"bool\"] = \"bool\";\n  PostgresTypes[\"date\"] = \"date\";\n  PostgresTypes[\"daterange\"] = \"daterange\";\n  PostgresTypes[\"float4\"] = \"float4\";\n  PostgresTypes[\"float8\"] = \"float8\";\n  PostgresTypes[\"int2\"] = \"int2\";\n  PostgresTypes[\"int4\"] = \"int4\";\n  PostgresTypes[\"int4range\"] = \"int4range\";\n  PostgresTypes[\"int8\"] = \"int8\";\n  PostgresTypes[\"int8range\"] = \"int8range\";\n  PostgresTypes[\"json\"] = \"json\";\n  PostgresTypes[\"jsonb\"] = \"jsonb\";\n  PostgresTypes[\"money\"] = \"money\";\n  PostgresTypes[\"numeric\"] = \"numeric\";\n  PostgresTypes[\"oid\"] = \"oid\";\n  PostgresTypes[\"reltime\"] = \"reltime\";\n  PostgresTypes[\"text\"] = \"text\";\n  PostgresTypes[\"time\"] = \"time\";\n  PostgresTypes[\"timestamp\"] = \"timestamp\";\n  PostgresTypes[\"timestamptz\"] = \"timestamptz\";\n  PostgresTypes[\"timetz\"] = \"timetz\";\n  PostgresTypes[\"tsrange\"] = \"tsrange\";\n  PostgresTypes[\"tstzrange\"] = \"tstzrange\";\n})(PostgresTypes || (PostgresTypes = {}));\n/**\n * Takes an array of columns and an object of string values then converts each string value\n * to its mapped type.\n *\n * @param {{name: String, type: String}[]} columns\n * @param {Object} record\n * @param {Object} options The map of various options that can be applied to the mapper\n * @param {Array} options.skipTypes The array of types that should not be converted\n *\n * @example convertChangeData([{name: 'first_name', type: 'text'}, {name: 'age', type: 'int4'}], {first_name: 'Paul', age:'33'}, {})\n * //=>{ first_name: 'Paul', age: 33 }\n */\n\n\nexport const convertChangeData = function (columns, record) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  var _a;\n\n  const skipTypes = (_a = options.skipTypes) !== null && _a !== void 0 ? _a : [];\n  return Object.keys(record).reduce((acc, rec_key) => {\n    acc[rec_key] = convertColumn(rec_key, columns, record, skipTypes);\n    return acc;\n  }, {});\n};\n/**\n * Converts the value of an individual column.\n *\n * @param {String} columnName The column that you want to convert\n * @param {{name: String, type: String}[]} columns All of the columns\n * @param {Object} record The map of string values\n * @param {Array} skipTypes An array of types that should not be converted\n * @return {object} Useless information\n *\n * @example convertColumn('age', [{name: 'first_name', type: 'text'}, {name: 'age', type: 'int4'}], {first_name: 'Paul', age: '33'}, [])\n * //=> 33\n * @example convertColumn('age', [{name: 'first_name', type: 'text'}, {name: 'age', type: 'int4'}], {first_name: 'Paul', age: '33'}, ['int4'])\n * //=> \"33\"\n */\n\nexport const convertColumn = (columnName, columns, record, skipTypes) => {\n  const column = columns.find(x => x.name === columnName);\n  const colType = column === null || column === void 0 ? void 0 : column.type;\n  const value = record[columnName];\n\n  if (colType && !skipTypes.includes(colType)) {\n    return convertCell(colType, value);\n  }\n\n  return noop(value);\n};\n/**\n * If the value of the cell is `null`, returns null.\n * Otherwise converts the string value to the correct type.\n * @param {String} type A postgres column type\n * @param {String} stringValue The cell value\n *\n * @example convertCell('bool', 't')\n * //=> true\n * @example convertCell('int8', '10')\n * //=> 10\n * @example convertCell('_int4', '{1,2,3,4}')\n * //=> [1,2,3,4]\n */\n\nexport const convertCell = (type, value) => {\n  // if data type is an array\n  if (type.charAt(0) === '_') {\n    const dataType = type.slice(1, type.length);\n    return toArray(value, dataType);\n  } // If not null, convert to correct type.\n\n\n  switch (type) {\n    case PostgresTypes.bool:\n      return toBoolean(value);\n\n    case PostgresTypes.float4:\n    case PostgresTypes.float8:\n    case PostgresTypes.int2:\n    case PostgresTypes.int4:\n    case PostgresTypes.int8:\n    case PostgresTypes.numeric:\n    case PostgresTypes.oid:\n      return toNumber(value);\n\n    case PostgresTypes.json:\n    case PostgresTypes.jsonb:\n      return toJson(value);\n\n    case PostgresTypes.timestamp:\n      return toTimestampString(value);\n    // Format to be consistent with PostgREST\n\n    case PostgresTypes.abstime: // To allow users to cast it based on Timezone\n\n    case PostgresTypes.date: // To allow users to cast it based on Timezone\n\n    case PostgresTypes.daterange:\n    case PostgresTypes.int4range:\n    case PostgresTypes.int8range:\n    case PostgresTypes.money:\n    case PostgresTypes.reltime: // To allow users to cast it based on Timezone\n\n    case PostgresTypes.text:\n    case PostgresTypes.time: // To allow users to cast it based on Timezone\n\n    case PostgresTypes.timestamptz: // To allow users to cast it based on Timezone\n\n    case PostgresTypes.timetz: // To allow users to cast it based on Timezone\n\n    case PostgresTypes.tsrange:\n    case PostgresTypes.tstzrange:\n      return noop(value);\n\n    default:\n      // Return the value for remaining types\n      return noop(value);\n  }\n};\n\nconst noop = value => {\n  return value;\n};\n\nexport const toBoolean = value => {\n  switch (value) {\n    case 't':\n      return true;\n\n    case 'f':\n      return false;\n\n    default:\n      return value;\n  }\n};\nexport const toNumber = value => {\n  if (typeof value === 'string') {\n    const parsedValue = parseFloat(value);\n\n    if (!Number.isNaN(parsedValue)) {\n      return parsedValue;\n    }\n  }\n\n  return value;\n};\nexport const toJson = value => {\n  if (typeof value === 'string') {\n    try {\n      return JSON.parse(value);\n    } catch (error) {\n      console.log(`JSON parse error: ${error}`);\n      return value;\n    }\n  }\n\n  return value;\n};\n/**\n * Converts a Postgres Array into a native JS array\n *\n * @example toArray('{}', 'int4')\n * //=> []\n * @example toArray('{\"[2021-01-01,2021-12-31)\",\"(2021-01-01,2021-12-32]\"}', 'daterange')\n * //=> ['[2021-01-01,2021-12-31)', '(2021-01-01,2021-12-32]']\n * @example toArray([1,2,3,4], 'int4')\n * //=> [1,2,3,4]\n */\n\nexport const toArray = (value, type) => {\n  if (typeof value !== 'string') {\n    return value;\n  }\n\n  const lastIdx = value.length - 1;\n  const closeBrace = value[lastIdx];\n  const openBrace = value[0]; // Confirm value is a Postgres array by checking curly brackets\n\n  if (openBrace === '{' && closeBrace === '}') {\n    let arr;\n    const valTrim = value.slice(1, lastIdx); // TODO: find a better solution to separate Postgres array data\n\n    try {\n      arr = JSON.parse('[' + valTrim + ']');\n    } catch (_) {\n      // WARNING: splitting on comma does not cover all edge cases\n      arr = valTrim ? valTrim.split(',') : [];\n    }\n\n    return arr.map(val => convertCell(type, val));\n  }\n\n  return value;\n};\n/**\n * Fixes timestamp to be ISO-8601. Swaps the space between the date and time for a 'T'\n * See https://github.com/supabase/supabase/issues/18\n *\n * @example toTimestampString('2019-09-10 00:00:00')\n * //=> '2019-09-10T00:00:00'\n */\n\nexport const toTimestampString = value => {\n  if (typeof value === 'string') {\n    return value.replace(' ', 'T');\n  }\n\n  return value;\n};","map":{"version":3,"sources":["/Users/joshpatel/supa-react/node_modules/@supabase/realtime-js/src/lib/transformers.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Helpers to convert the change Payload into native JS types.\n */\n\n// Adapted from epgsql (src/epgsql_binary.erl), this module licensed under\n// 3-clause BSD found here: https://raw.githubusercontent.com/epgsql/epgsql/devel/LICENSE\n\nexport enum PostgresTypes {\n  abstime = 'abstime',\n  bool = 'bool',\n  date = 'date',\n  daterange = 'daterange',\n  float4 = 'float4',\n  float8 = 'float8',\n  int2 = 'int2',\n  int4 = 'int4',\n  int4range = 'int4range',\n  int8 = 'int8',\n  int8range = 'int8range',\n  json = 'json',\n  jsonb = 'jsonb',\n  money = 'money',\n  numeric = 'numeric',\n  oid = 'oid',\n  reltime = 'reltime',\n  text = 'text',\n  time = 'time',\n  timestamp = 'timestamp',\n  timestamptz = 'timestamptz',\n  timetz = 'timetz',\n  tsrange = 'tsrange',\n  tstzrange = 'tstzrange',\n}\n\ntype Columns = {\n  name: string // the column name. eg: \"user_id\"\n  type: string // the column type. eg: \"uuid\"\n  flags?: string[] // any special flags for the column. eg: [\"key\"]\n  type_modifier?: number // the type modifier. eg: 4294967295\n}[]\n\ntype BaseValue = null | string | number | boolean\ntype RecordValue = BaseValue | BaseValue[]\n\ntype Record = {\n  [key: string]: RecordValue\n}\n\n/**\n * Takes an array of columns and an object of string values then converts each string value\n * to its mapped type.\n *\n * @param {{name: String, type: String}[]} columns\n * @param {Object} record\n * @param {Object} options The map of various options that can be applied to the mapper\n * @param {Array} options.skipTypes The array of types that should not be converted\n *\n * @example convertChangeData([{name: 'first_name', type: 'text'}, {name: 'age', type: 'int4'}], {first_name: 'Paul', age:'33'}, {})\n * //=>{ first_name: 'Paul', age: 33 }\n */\nexport const convertChangeData = (\n  columns: Columns,\n  record: Record,\n  options: { skipTypes?: string[] } = {}\n): Record => {\n  const skipTypes = options.skipTypes ?? []\n\n  return Object.keys(record).reduce((acc, rec_key) => {\n    acc[rec_key] = convertColumn(rec_key, columns, record, skipTypes)\n    return acc\n  }, {} as Record)\n}\n\n/**\n * Converts the value of an individual column.\n *\n * @param {String} columnName The column that you want to convert\n * @param {{name: String, type: String}[]} columns All of the columns\n * @param {Object} record The map of string values\n * @param {Array} skipTypes An array of types that should not be converted\n * @return {object} Useless information\n *\n * @example convertColumn('age', [{name: 'first_name', type: 'text'}, {name: 'age', type: 'int4'}], {first_name: 'Paul', age: '33'}, [])\n * //=> 33\n * @example convertColumn('age', [{name: 'first_name', type: 'text'}, {name: 'age', type: 'int4'}], {first_name: 'Paul', age: '33'}, ['int4'])\n * //=> \"33\"\n */\nexport const convertColumn = (\n  columnName: string,\n  columns: Columns,\n  record: Record,\n  skipTypes: string[]\n): RecordValue => {\n  const column = columns.find((x) => x.name === columnName)\n  const colType = column?.type\n  const value = record[columnName]\n\n  if (colType && !skipTypes.includes(colType)) {\n    return convertCell(colType, value)\n  }\n\n  return noop(value)\n}\n\n/**\n * If the value of the cell is `null`, returns null.\n * Otherwise converts the string value to the correct type.\n * @param {String} type A postgres column type\n * @param {String} stringValue The cell value\n *\n * @example convertCell('bool', 't')\n * //=> true\n * @example convertCell('int8', '10')\n * //=> 10\n * @example convertCell('_int4', '{1,2,3,4}')\n * //=> [1,2,3,4]\n */\nexport const convertCell = (type: string, value: RecordValue): RecordValue => {\n  // if data type is an array\n  if (type.charAt(0) === '_') {\n    const dataType = type.slice(1, type.length)\n    return toArray(value, dataType)\n  }\n\n  // If not null, convert to correct type.\n  switch (type) {\n    case PostgresTypes.bool:\n      return toBoolean(value)\n    case PostgresTypes.float4:\n    case PostgresTypes.float8:\n    case PostgresTypes.int2:\n    case PostgresTypes.int4:\n    case PostgresTypes.int8:\n    case PostgresTypes.numeric:\n    case PostgresTypes.oid:\n      return toNumber(value)\n    case PostgresTypes.json:\n    case PostgresTypes.jsonb:\n      return toJson(value)\n    case PostgresTypes.timestamp:\n      return toTimestampString(value) // Format to be consistent with PostgREST\n    case PostgresTypes.abstime: // To allow users to cast it based on Timezone\n    case PostgresTypes.date: // To allow users to cast it based on Timezone\n    case PostgresTypes.daterange:\n    case PostgresTypes.int4range:\n    case PostgresTypes.int8range:\n    case PostgresTypes.money:\n    case PostgresTypes.reltime: // To allow users to cast it based on Timezone\n    case PostgresTypes.text:\n    case PostgresTypes.time: // To allow users to cast it based on Timezone\n    case PostgresTypes.timestamptz: // To allow users to cast it based on Timezone\n    case PostgresTypes.timetz: // To allow users to cast it based on Timezone\n    case PostgresTypes.tsrange:\n    case PostgresTypes.tstzrange:\n      return noop(value)\n    default:\n      // Return the value for remaining types\n      return noop(value)\n  }\n}\n\nconst noop = (value: RecordValue): RecordValue => {\n  return value\n}\nexport const toBoolean = (value: RecordValue): RecordValue => {\n  switch (value) {\n    case 't':\n      return true\n    case 'f':\n      return false\n    default:\n      return value\n  }\n}\nexport const toNumber = (value: RecordValue): RecordValue => {\n  if (typeof value === 'string') {\n    const parsedValue = parseFloat(value)\n    if (!Number.isNaN(parsedValue)) {\n      return parsedValue\n    }\n  }\n  return value\n}\nexport const toJson = (value: RecordValue): RecordValue => {\n  if (typeof value === 'string') {\n    try {\n      return JSON.parse(value)\n    } catch (error) {\n      console.log(`JSON parse error: ${error}`)\n      return value\n    }\n  }\n  return value\n}\n\n/**\n * Converts a Postgres Array into a native JS array\n *\n * @example toArray('{}', 'int4')\n * //=> []\n * @example toArray('{\"[2021-01-01,2021-12-31)\",\"(2021-01-01,2021-12-32]\"}', 'daterange')\n * //=> ['[2021-01-01,2021-12-31)', '(2021-01-01,2021-12-32]']\n * @example toArray([1,2,3,4], 'int4')\n * //=> [1,2,3,4]\n */\nexport const toArray = (value: RecordValue, type: string): RecordValue => {\n  if (typeof value !== 'string') {\n    return value\n  }\n\n  const lastIdx = value.length - 1\n  const closeBrace = value[lastIdx]\n  const openBrace = value[0]\n\n  // Confirm value is a Postgres array by checking curly brackets\n  if (openBrace === '{' && closeBrace === '}') {\n    let arr\n    const valTrim = value.slice(1, lastIdx)\n\n    // TODO: find a better solution to separate Postgres array data\n    try {\n      arr = JSON.parse('[' + valTrim + ']')\n    } catch (_) {\n      // WARNING: splitting on comma does not cover all edge cases\n      arr = valTrim ? valTrim.split(',') : []\n    }\n\n    return arr.map((val: BaseValue) => convertCell(type, val))\n  }\n\n  return value\n}\n\n/**\n * Fixes timestamp to be ISO-8601. Swaps the space between the date and time for a 'T'\n * See https://github.com/supabase/supabase/issues/18\n *\n * @example toTimestampString('2019-09-10 00:00:00')\n * //=> '2019-09-10T00:00:00'\n */\nexport const toTimestampString = (value: RecordValue): RecordValue => {\n  if (typeof value === 'string') {\n    return value.replace(' ', 'T')\n  }\n\n  return value\n}\n"]},"metadata":{},"sourceType":"module"}