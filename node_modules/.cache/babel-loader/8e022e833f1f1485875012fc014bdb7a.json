{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { get, post, put, remove } from './lib/fetch';\nimport { COOKIE_OPTIONS } from './lib/constants';\nimport { setCookie, deleteCookie } from './lib/cookies';\nimport { expiresAt } from './lib/helpers';\nexport default class GoTrueApi {\n  constructor(_ref) {\n    let {\n      url = '',\n      headers = {},\n      cookieOptions,\n      fetch\n    } = _ref;\n    this.url = url;\n    this.headers = headers;\n    this.cookieOptions = Object.assign(Object.assign({}, COOKIE_OPTIONS), cookieOptions);\n    this.fetch = fetch;\n  }\n  /**\n   * Creates a new user.\n   *\n   * This function should only be called on a server. Never expose your `service_role` key in the browser.\n   *\n   * @param attributes The data you want to create the user with.\n   * @param jwt A valid JWT. Must be a full-access API key (e.g. service_role key).\n   */\n\n\n  createUser(attributes) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const data = yield post(this.fetch, `${this.url}/admin/users`, attributes, {\n          headers: this.headers\n        });\n        return {\n          data,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Get a list of users.\n   *\n   * This function should only be called on a server. Never expose your `service_role` key in the browser.\n   */\n\n\n  listUsers() {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const data = yield get(this.fetch, `${this.url}/admin/users`, {\n          headers: this.headers\n        });\n        return {\n          data: data.users,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Creates a new user using their email address.\n   * @param email The email address of the user.\n   * @param password The password of the user.\n   * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n   * @param data Optional user metadata.\n   *\n   * @returns A logged-in session if the server has \"autoconfirm\" ON\n   * @returns A user if the server has \"autoconfirm\" OFF\n   */\n\n\n  signUpWithEmail(email, password) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const headers = Object.assign({}, this.headers);\n        let queryString = '';\n\n        if (options.redirectTo) {\n          queryString = '?redirect_to=' + encodeURIComponent(options.redirectTo);\n        }\n\n        const data = yield post(this.fetch, `${this.url}/signup${queryString}`, {\n          email,\n          password,\n          data: options.data\n        }, {\n          headers\n        });\n        const session = Object.assign({}, data);\n        if (session.expires_in) session.expires_at = expiresAt(data.expires_in);\n        return {\n          data: session,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Logs in an existing user using their email address.\n   * @param email The email address of the user.\n   * @param password The password of the user.\n   * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n   */\n\n\n  signInWithEmail(email, password) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const headers = Object.assign({}, this.headers);\n        let queryString = '?grant_type=password';\n\n        if (options.redirectTo) {\n          queryString += '&redirect_to=' + encodeURIComponent(options.redirectTo);\n        }\n\n        const data = yield post(this.fetch, `${this.url}/token${queryString}`, {\n          email,\n          password\n        }, {\n          headers\n        });\n        const session = Object.assign({}, data);\n        if (session.expires_in) session.expires_at = expiresAt(data.expires_in);\n        return {\n          data: session,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Signs up a new user using their phone number and a password.\n   * @param phone The phone number of the user.\n   * @param password The password of the user.\n   * @param data Optional user metadata.\n   */\n\n\n  signUpWithPhone(phone, password) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const headers = Object.assign({}, this.headers);\n        const data = yield post(this.fetch, `${this.url}/signup`, {\n          phone,\n          password,\n          data: options.data\n        }, {\n          headers\n        });\n        const session = Object.assign({}, data);\n        if (session.expires_in) session.expires_at = expiresAt(data.expires_in);\n        return {\n          data: session,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Logs in an existing user using their phone number and password.\n   * @param phone The phone number of the user.\n   * @param password The password of the user.\n   */\n\n\n  signInWithPhone(phone, password) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const headers = Object.assign({}, this.headers);\n        const queryString = '?grant_type=password';\n        const data = yield post(this.fetch, `${this.url}/token${queryString}`, {\n          phone,\n          password\n        }, {\n          headers\n        });\n        const session = Object.assign({}, data);\n        if (session.expires_in) session.expires_at = expiresAt(data.expires_in);\n        return {\n          data: session,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Sends a magic login link to an email address.\n   * @param email The email address of the user.\n   * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n   */\n\n\n  sendMagicLinkEmail(email) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const headers = Object.assign({}, this.headers);\n        let queryString = '';\n\n        if (options.redirectTo) {\n          queryString += '?redirect_to=' + encodeURIComponent(options.redirectTo);\n        }\n\n        const data = yield post(this.fetch, `${this.url}/magiclink${queryString}`, {\n          email\n        }, {\n          headers\n        });\n        return {\n          data,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Sends a mobile OTP via SMS. Will register the account if it doesn't already exist\n   * @param phone The user's phone number WITH international prefix\n   */\n\n\n  sendMobileOTP(phone) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const headers = Object.assign({}, this.headers);\n        const data = yield post(this.fetch, `${this.url}/otp`, {\n          phone\n        }, {\n          headers\n        });\n        return {\n          data,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Send User supplied Mobile OTP to be verified\n   * @param phone The user's phone number WITH international prefix\n   * @param token token that user was sent to their mobile phone\n   * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n   */\n\n\n  verifyMobileOTP(phone, token) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const headers = Object.assign({}, this.headers);\n        const data = yield post(this.fetch, `${this.url}/verify`, {\n          phone,\n          token,\n          type: 'sms',\n          redirect_to: options.redirectTo\n        }, {\n          headers\n        });\n        return {\n          data,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Sends an invite link to an email address.\n   * @param email The email address of the user.\n   * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n   * @param data Optional user metadata\n   */\n\n\n  inviteUserByEmail(email) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const headers = Object.assign({}, this.headers);\n        let queryString = '';\n\n        if (options.redirectTo) {\n          queryString += '?redirect_to=' + encodeURIComponent(options.redirectTo);\n        }\n\n        const data = yield post(this.fetch, `${this.url}/invite${queryString}`, {\n          email,\n          data: options.data\n        }, {\n          headers\n        });\n        return {\n          data,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Sends a reset request to an email address.\n   * @param email The email address of the user.\n   * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n   */\n\n\n  resetPasswordForEmail(email) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const headers = Object.assign({}, this.headers);\n        let queryString = '';\n\n        if (options.redirectTo) {\n          queryString += '?redirect_to=' + encodeURIComponent(options.redirectTo);\n        }\n\n        const data = yield post(this.fetch, `${this.url}/recover${queryString}`, {\n          email\n        }, {\n          headers\n        });\n        return {\n          data,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Create a temporary object with all configured headers and\n   * adds the Authorization token to be used on request methods\n   * @param jwt A valid, logged-in JWT.\n   */\n\n\n  _createRequestHeaders(jwt) {\n    const headers = Object.assign({}, this.headers);\n    headers['Authorization'] = `Bearer ${jwt}`;\n    return headers;\n  }\n  /**\n   * Removes a logged-in session.\n   * @param jwt A valid, logged-in JWT.\n   */\n\n\n  signOut(jwt) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        yield post(this.fetch, `${this.url}/logout`, {}, {\n          headers: this._createRequestHeaders(jwt),\n          noResolveJson: true\n        });\n        return {\n          error: null\n        };\n      } catch (e) {\n        return {\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Generates the relevant login URL for a third-party provider.\n   * @param provider One of the providers supported by GoTrue.\n   * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n   * @param scopes A space-separated list of scopes granted to the OAuth application.\n   */\n\n\n  getUrlForProvider(provider, options) {\n    const urlParams = [`provider=${encodeURIComponent(provider)}`];\n\n    if (options === null || options === void 0 ? void 0 : options.redirectTo) {\n      urlParams.push(`redirect_to=${encodeURIComponent(options.redirectTo)}`);\n    }\n\n    if (options === null || options === void 0 ? void 0 : options.scopes) {\n      urlParams.push(`scopes=${encodeURIComponent(options.scopes)}`);\n    }\n\n    return `${this.url}/authorize?${urlParams.join('&')}`;\n  }\n  /**\n   * Gets the user details.\n   * @param jwt A valid, logged-in JWT.\n   */\n\n\n  getUser(jwt) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const data = yield get(this.fetch, `${this.url}/user`, {\n          headers: this._createRequestHeaders(jwt)\n        });\n        return {\n          user: data,\n          data,\n          error: null\n        };\n      } catch (e) {\n        return {\n          user: null,\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Updates the user data.\n   * @param jwt A valid, logged-in JWT.\n   * @param attributes The data you want to update.\n   */\n\n\n  updateUser(jwt, attributes) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const data = yield put(this.fetch, `${this.url}/user`, attributes, {\n          headers: this._createRequestHeaders(jwt)\n        });\n        return {\n          user: data,\n          data,\n          error: null\n        };\n      } catch (e) {\n        return {\n          user: null,\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Delete a user. Requires a `service_role` key.\n   *\n   * This function should only be called on a server. Never expose your `service_role` key in the browser.\n   *\n   * @param uid The user uid you want to remove.\n   * @param jwt A valid JWT. Must be a full-access API key (e.g. service_role key).\n   */\n\n\n  deleteUser(uid, jwt) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const data = yield remove(this.fetch, `${this.url}/admin/users/${uid}`, {}, {\n          headers: this._createRequestHeaders(jwt)\n        });\n        return {\n          user: data,\n          data,\n          error: null\n        };\n      } catch (e) {\n        return {\n          user: null,\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Generates a new JWT.\n   * @param refreshToken A valid refresh token that was returned on login.\n   */\n\n\n  refreshAccessToken(refreshToken) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const data = yield post(this.fetch, `${this.url}/token?grant_type=refresh_token`, {\n          refresh_token: refreshToken\n        }, {\n          headers: this.headers\n        });\n        const session = Object.assign({}, data);\n        if (session.expires_in) session.expires_at = expiresAt(data.expires_in);\n        return {\n          data: session,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Set/delete the auth cookie based on the AuthChangeEvent.\n   * Works for Next.js & Express (requires cookie-parser middleware).\n   */\n\n\n  setAuthCookie(req, res) {\n    if (req.method !== 'POST') {\n      res.setHeader('Allow', 'POST');\n      res.status(405).end('Method Not Allowed');\n    }\n\n    const {\n      event,\n      session\n    } = req.body;\n    if (!event) throw new Error('Auth event missing!');\n\n    if (event === 'SIGNED_IN') {\n      if (!session) throw new Error('Auth session missing!');\n      setCookie(req, res, {\n        name: this.cookieOptions.name,\n        value: session.access_token,\n        domain: this.cookieOptions.domain,\n        maxAge: this.cookieOptions.lifetime,\n        path: this.cookieOptions.path,\n        sameSite: this.cookieOptions.sameSite\n      });\n    }\n\n    if (event === 'SIGNED_OUT') deleteCookie(req, res, this.cookieOptions.name);\n    res.status(200).json({});\n  }\n  /**\n   * Get user by reading the cookie from the request.\n   * Works for Next.js & Express (requires cookie-parser middleware).\n   */\n\n\n  getUserByCookie(req) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        if (!req.cookies) {\n          throw new Error('Not able to parse cookies! When using Express make sure the cookie-parser middleware is in use!');\n        }\n\n        if (!req.cookies[this.cookieOptions.name]) {\n          throw new Error('No cookie found!');\n        }\n\n        const token = req.cookies[this.cookieOptions.name];\n        const {\n          user,\n          error\n        } = yield this.getUser(token);\n        if (error) throw error;\n        return {\n          token,\n          user,\n          data: user,\n          error: null\n        };\n      } catch (e) {\n        return {\n          token: null,\n          user: null,\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Generates links to be sent via email or other.\n   * @param type The link type (\"signup\" or \"magiclink\" or \"recovery\" or \"invite\").\n   * @param email The user's email.\n   * @param password User password. For signup only.\n   * @param data Optional user metadata. For signup only.\n   * @param redirectTo The link type (\"signup\" or \"magiclink\" or \"recovery\" or \"invite\").\n   */\n\n\n  generateLink(type, email) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const data = yield post(this.fetch, `${this.url}/admin/generate_link`, {\n          type,\n          email,\n          password: options.password,\n          data: options.data,\n          redirect_to: options.redirectTo\n        }, {\n          headers: this.headers\n        });\n        return {\n          data,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n\n}","map":{"version":3,"sources":["/Users/joshpatel/supa-react/node_modules/@supabase/gotrue-js/src/GoTrueApi.ts"],"names":[],"mappings":"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","sourcesContent":["import { Fetch, get, post, put, remove } from './lib/fetch'\nimport { Session, Provider, UserAttributes, CookieOptions, User } from './lib/types'\nimport { COOKIE_OPTIONS } from './lib/constants'\nimport { setCookie, deleteCookie } from './lib/cookies'\nimport { expiresAt } from './lib/helpers'\n\nimport type { ApiError } from './lib/types'\nexport default class GoTrueApi {\n  protected url: string\n  protected headers: {\n    [key: string]: string\n  }\n  protected cookieOptions: CookieOptions\n  protected fetch?: Fetch\n\n  constructor({\n    url = '',\n    headers = {},\n    cookieOptions,\n    fetch,\n  }: {\n    url: string\n    headers?: {\n      [key: string]: string\n    }\n    cookieOptions?: CookieOptions\n    fetch?: Fetch\n  }) {\n    this.url = url\n    this.headers = headers\n    this.cookieOptions = { ...COOKIE_OPTIONS, ...cookieOptions }\n    this.fetch = fetch\n  }\n\n  /**\n   * Creates a new user.\n   *\n   * This function should only be called on a server. Never expose your `service_role` key in the browser.\n   *\n   * @param attributes The data you want to create the user with.\n   * @param jwt A valid JWT. Must be a full-access API key (e.g. service_role key).\n   */\n  async createUser(\n    attributes: UserAttributes\n  ): Promise<{ data: null; error: ApiError } | { data: User; error: null }> {\n    try {\n      const data: any = await post(this.fetch, `${this.url}/admin/users`, attributes, {\n        headers: this.headers,\n      })\n      return { data, error: null }\n    } catch (e) {\n      return { data: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Get a list of users.\n   *\n   * This function should only be called on a server. Never expose your `service_role` key in the browser.\n   */\n  async listUsers(): Promise<{ data: null; error: ApiError } | { data: User[]; error: null }> {\n    try {\n      const data: any = await get(this.fetch, `${this.url}/admin/users`, {\n        headers: this.headers,\n      })\n      return { data: data.users, error: null }\n    } catch (e) {\n      return { data: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Creates a new user using their email address.\n   * @param email The email address of the user.\n   * @param password The password of the user.\n   * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n   * @param data Optional user metadata.\n   *\n   * @returns A logged-in session if the server has \"autoconfirm\" ON\n   * @returns A user if the server has \"autoconfirm\" OFF\n   */\n  async signUpWithEmail(\n    email: string,\n    password: string,\n    options: {\n      redirectTo?: string\n      data?: object\n    } = {}\n  ): Promise<{ data: Session | User | null; error: ApiError | null }> {\n    try {\n      const headers = { ...this.headers }\n      let queryString = ''\n      if (options.redirectTo) {\n        queryString = '?redirect_to=' + encodeURIComponent(options.redirectTo)\n      }\n      const data = await post(\n        this.fetch,\n        `${this.url}/signup${queryString}`,\n        { email, password, data: options.data },\n        { headers }\n      )\n      const session = { ...data }\n      if (session.expires_in) session.expires_at = expiresAt(data.expires_in)\n      return { data: session, error: null }\n    } catch (e) {\n      return { data: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Logs in an existing user using their email address.\n   * @param email The email address of the user.\n   * @param password The password of the user.\n   * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n   */\n  async signInWithEmail(\n    email: string,\n    password: string,\n    options: {\n      redirectTo?: string\n    } = {}\n  ): Promise<{ data: Session | null; error: ApiError | null }> {\n    try {\n      const headers = { ...this.headers }\n      let queryString = '?grant_type=password'\n      if (options.redirectTo) {\n        queryString += '&redirect_to=' + encodeURIComponent(options.redirectTo)\n      }\n      const data = await post(\n        this.fetch,\n        `${this.url}/token${queryString}`,\n        { email, password },\n        { headers }\n      )\n      const session = { ...data }\n      if (session.expires_in) session.expires_at = expiresAt(data.expires_in)\n      return { data: session, error: null }\n    } catch (e) {\n      return { data: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Signs up a new user using their phone number and a password.\n   * @param phone The phone number of the user.\n   * @param password The password of the user.\n   * @param data Optional user metadata.\n   */\n  async signUpWithPhone(\n    phone: string,\n    password: string,\n    options: {\n      data?: object\n    } = {}\n  ): Promise<{ data: Session | User | null; error: ApiError | null }> {\n    try {\n      const headers = { ...this.headers }\n      const data = await post(\n        this.fetch,\n        `${this.url}/signup`,\n        { phone, password, data: options.data },\n        { headers }\n      )\n      const session = { ...data }\n      if (session.expires_in) session.expires_at = expiresAt(data.expires_in)\n      return { data: session, error: null }\n    } catch (e) {\n      return { data: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Logs in an existing user using their phone number and password.\n   * @param phone The phone number of the user.\n   * @param password The password of the user.\n   */\n  async signInWithPhone(\n    phone: string,\n    password: string\n  ): Promise<{ data: Session | null; error: ApiError | null }> {\n    try {\n      const headers = { ...this.headers }\n      const queryString = '?grant_type=password'\n      const data = await post(\n        this.fetch,\n        `${this.url}/token${queryString}`,\n        { phone, password },\n        { headers }\n      )\n      const session = { ...data }\n      if (session.expires_in) session.expires_at = expiresAt(data.expires_in)\n      return { data: session, error: null }\n    } catch (e) {\n      return { data: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Sends a magic login link to an email address.\n   * @param email The email address of the user.\n   * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n   */\n  async sendMagicLinkEmail(\n    email: string,\n    options: {\n      redirectTo?: string\n    } = {}\n  ): Promise<{ data: {} | null; error: ApiError | null }> {\n    try {\n      const headers = { ...this.headers }\n      let queryString = ''\n      if (options.redirectTo) {\n        queryString += '?redirect_to=' + encodeURIComponent(options.redirectTo)\n      }\n      const data = await post(\n        this.fetch,\n        `${this.url}/magiclink${queryString}`,\n        { email },\n        { headers }\n      )\n      return { data, error: null }\n    } catch (e) {\n      return { data: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Sends a mobile OTP via SMS. Will register the account if it doesn't already exist\n   * @param phone The user's phone number WITH international prefix\n   */\n  async sendMobileOTP(phone: string): Promise<{ data: {} | null; error: ApiError | null }> {\n    try {\n      const headers = { ...this.headers }\n      const data = await post(this.fetch, `${this.url}/otp`, { phone }, { headers })\n      return { data, error: null }\n    } catch (e) {\n      return { data: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Send User supplied Mobile OTP to be verified\n   * @param phone The user's phone number WITH international prefix\n   * @param token token that user was sent to their mobile phone\n   * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n   */\n  async verifyMobileOTP(\n    phone: string,\n    token: string,\n    options: {\n      redirectTo?: string\n    } = {}\n  ): Promise<{ data: Session | User | null; error: ApiError | null }> {\n    try {\n      const headers = { ...this.headers }\n      const data = await post(\n        this.fetch,\n        `${this.url}/verify`,\n        { phone, token, type: 'sms', redirect_to: options.redirectTo },\n        { headers }\n      )\n      return { data, error: null }\n    } catch (e) {\n      return { data: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Sends an invite link to an email address.\n   * @param email The email address of the user.\n   * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n   * @param data Optional user metadata\n   */\n  async inviteUserByEmail(\n    email: string,\n    options: {\n      redirectTo?: string\n      data?: object\n    } = {}\n  ): Promise<{ data: User | null; error: ApiError | null }> {\n    try {\n      const headers = { ...this.headers }\n      let queryString = ''\n      if (options.redirectTo) {\n        queryString += '?redirect_to=' + encodeURIComponent(options.redirectTo)\n      }\n      const data = await post(\n        this.fetch,\n        `${this.url}/invite${queryString}`,\n        { email, data: options.data },\n        { headers }\n      )\n      return { data, error: null }\n    } catch (e) {\n      return { data: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Sends a reset request to an email address.\n   * @param email The email address of the user.\n   * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n   */\n  async resetPasswordForEmail(\n    email: string,\n    options: {\n      redirectTo?: string\n    } = {}\n  ): Promise<{ data: {} | null; error: ApiError | null }> {\n    try {\n      const headers = { ...this.headers }\n      let queryString = ''\n      if (options.redirectTo) {\n        queryString += '?redirect_to=' + encodeURIComponent(options.redirectTo)\n      }\n      const data = await post(\n        this.fetch,\n        `${this.url}/recover${queryString}`,\n        { email },\n        { headers }\n      )\n      return { data, error: null }\n    } catch (e) {\n      return { data: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Create a temporary object with all configured headers and\n   * adds the Authorization token to be used on request methods\n   * @param jwt A valid, logged-in JWT.\n   */\n  private _createRequestHeaders(jwt: string) {\n    const headers = { ...this.headers }\n    headers['Authorization'] = `Bearer ${jwt}`\n    return headers\n  }\n\n  /**\n   * Removes a logged-in session.\n   * @param jwt A valid, logged-in JWT.\n   */\n  async signOut(jwt: string): Promise<{ error: ApiError | null }> {\n    try {\n      await post(\n        this.fetch,\n        `${this.url}/logout`,\n        {},\n        { headers: this._createRequestHeaders(jwt), noResolveJson: true }\n      )\n      return { error: null }\n    } catch (e) {\n      return { error: e as ApiError }\n    }\n  }\n\n  /**\n   * Generates the relevant login URL for a third-party provider.\n   * @param provider One of the providers supported by GoTrue.\n   * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n   * @param scopes A space-separated list of scopes granted to the OAuth application.\n   */\n  getUrlForProvider(\n    provider: Provider,\n    options: {\n      redirectTo?: string\n      scopes?: string\n    }\n  ) {\n    const urlParams: string[] = [`provider=${encodeURIComponent(provider)}`]\n    if (options?.redirectTo) {\n      urlParams.push(`redirect_to=${encodeURIComponent(options.redirectTo)}`)\n    }\n    if (options?.scopes) {\n      urlParams.push(`scopes=${encodeURIComponent(options.scopes)}`)\n    }\n    return `${this.url}/authorize?${urlParams.join('&')}`\n  }\n\n  /**\n   * Gets the user details.\n   * @param jwt A valid, logged-in JWT.\n   */\n  async getUser(\n    jwt: string\n  ): Promise<{ user: User | null; data: User | null; error: ApiError | null }> {\n    try {\n      const data: any = await get(this.fetch, `${this.url}/user`, {\n        headers: this._createRequestHeaders(jwt),\n      })\n      return { user: data, data, error: null }\n    } catch (e) {\n      return { user: null, data: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Updates the user data.\n   * @param jwt A valid, logged-in JWT.\n   * @param attributes The data you want to update.\n   */\n  async updateUser(\n    jwt: string,\n    attributes: UserAttributes\n  ): Promise<{ user: User | null; data: User | null; error: ApiError | null }> {\n    try {\n      const data: any = await put(this.fetch, `${this.url}/user`, attributes, {\n        headers: this._createRequestHeaders(jwt),\n      })\n      return { user: data, data, error: null }\n    } catch (e) {\n      return { user: null, data: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Delete a user. Requires a `service_role` key.\n   *\n   * This function should only be called on a server. Never expose your `service_role` key in the browser.\n   *\n   * @param uid The user uid you want to remove.\n   * @param jwt A valid JWT. Must be a full-access API key (e.g. service_role key).\n   */\n  async deleteUser(\n    uid: string,\n    jwt: string\n  ): Promise<{ user: User | null; data: User | null; error: ApiError | null }> {\n    try {\n      const data: any = await remove(\n        this.fetch,\n        `${this.url}/admin/users/${uid}`,\n        {},\n        {\n          headers: this._createRequestHeaders(jwt),\n        }\n      )\n      return { user: data, data, error: null }\n    } catch (e) {\n      return { user: null, data: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Generates a new JWT.\n   * @param refreshToken A valid refresh token that was returned on login.\n   */\n  async refreshAccessToken(\n    refreshToken: string\n  ): Promise<{ data: Session | null; error: ApiError | null }> {\n    try {\n      const data: any = await post(\n        this.fetch,\n        `${this.url}/token?grant_type=refresh_token`,\n        { refresh_token: refreshToken },\n        { headers: this.headers }\n      )\n      const session = { ...data }\n      if (session.expires_in) session.expires_at = expiresAt(data.expires_in)\n      return { data: session, error: null }\n    } catch (e) {\n      return { data: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Set/delete the auth cookie based on the AuthChangeEvent.\n   * Works for Next.js & Express (requires cookie-parser middleware).\n   */\n  setAuthCookie(req: any, res: any) {\n    if (req.method !== 'POST') {\n      res.setHeader('Allow', 'POST')\n      res.status(405).end('Method Not Allowed')\n    }\n    const { event, session } = req.body\n    if (!event) throw new Error('Auth event missing!')\n    if (event === 'SIGNED_IN') {\n      if (!session) throw new Error('Auth session missing!')\n      setCookie(req, res, {\n        name: this.cookieOptions.name!,\n        value: session.access_token,\n        domain: this.cookieOptions.domain,\n        maxAge: this.cookieOptions.lifetime!,\n        path: this.cookieOptions.path,\n        sameSite: this.cookieOptions.sameSite,\n      })\n    }\n    if (event === 'SIGNED_OUT') deleteCookie(req, res, this.cookieOptions.name!)\n    res.status(200).json({})\n  }\n\n  /**\n   * Get user by reading the cookie from the request.\n   * Works for Next.js & Express (requires cookie-parser middleware).\n   */\n  async getUserByCookie(req: any): Promise<{\n    token: string | null\n    user: User | null\n    data: User | null\n    error: ApiError | null\n  }> {\n    try {\n      if (!req.cookies) {\n        throw new Error(\n          'Not able to parse cookies! When using Express make sure the cookie-parser middleware is in use!'\n        )\n      }\n      if (!req.cookies[this.cookieOptions.name!]) {\n        throw new Error('No cookie found!')\n      }\n      const token = req.cookies[this.cookieOptions.name!]\n      const { user, error } = await this.getUser(token)\n      if (error) throw error\n      return { token, user, data: user, error: null }\n    } catch (e) {\n      return { token: null, user: null, data: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Generates links to be sent via email or other.\n   * @param type The link type (\"signup\" or \"magiclink\" or \"recovery\" or \"invite\").\n   * @param email The user's email.\n   * @param password User password. For signup only.\n   * @param data Optional user metadata. For signup only.\n   * @param redirectTo The link type (\"signup\" or \"magiclink\" or \"recovery\" or \"invite\").\n   */\n  async generateLink(\n    type: 'signup' | 'magiclink' | 'recovery' | 'invite',\n    email: string,\n    options: {\n      password?: string\n      data?: object\n      redirectTo?: string\n    } = {}\n  ): Promise<{ data: Session | User | null; error: ApiError | null }> {\n    try {\n      const data: any = await post(\n        this.fetch,\n        `${this.url}/admin/generate_link`,\n        {\n          type,\n          email,\n          password: options.password,\n          data: options.data,\n          redirect_to: options.redirectTo,\n        },\n        { headers: this.headers }\n      )\n      return { data, error: null }\n    } catch (e) {\n      return { data: null, error: e as ApiError }\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}